# Week5 学习笔记

## CSS 计算 | 收集 CSS 规则

环境准备： npm install css - css -> AST

1. 收集 CSS 规则

- 遇到 style 标签时（endTag 逻辑），把 css 规则保存起来
- 调用 CSS Parser 来分析 css 规则，转换为 AST
- 注意产生的 AST 结构

---

## CSS 计算 | 添加调用

- 在 startTag 创建元素后，立即计算 css
- 理论上，当分析一个元素时，所有 CSS 规则已经收集完毕
  - 所有 head 里的元素，是没有办法计算它的 CSS 的
- 在真实浏览器中，可能遇到写在 body 的 style 标签，需要重新 CSS 计算的情况，这里暂时忽略

---

## CSS 计算 | 获取父元素序列

- 在 computeCSS 函数中，必须知道元素的所有父元素才能判断元素与股则是否匹配
- 从 stack 中获取本元素所有的父元素
- 因为首先获得的是“当前元素”，所以获得和计算父元素匹配的顺序是从内向外
  - div div #myid

---

## CSS 计算 | 选择器与元素的匹配

- 选择器也要从当前元素向外排列
- 复杂选择器拆成单个元素的选择器，用循环匹配父元素队列

---

## CSS 计算 | 计算选择器与元素匹配

- 根据选择器的类型和元素属性，计算是否与当前元素匹配
- 这里仅仅实现了三种基本选择器，实际浏览器中药处理复合选择器

---

## CSS 计算 | 生成 computed 属性

- 一旦选择匹配，就应用选择器到元素上，形成 computedStyle

## CSS 计算 | specificity 的计算逻辑

优先级 - 专指程度

**四元组：**
[0, 0, 0, 0] - [inline, id, class, tag] => 从左到右权重依次下降

Ex.

- div div #id
- [0, 1, 0, 2]

Ex.

- div #my #id
- [0, 2, 0, 1]

比较规则：

- 只要高位能比较出来，就不考虑低位

### 总结

- CSS 规则根据 specificity 和后来优先规则覆盖
- specificity 是四元组，左边权重高
- 一个 CSS 规则的 specificity 是根据所包含的简单选择器相加而成

---

## 排版 | 根据浏览器属性进行排版

1. 正常流
2. **flex**
3. grid

Layout 发生时机：标签结束标签之前

> 将 width, height 等抽象成 main, cross 相关属性

---

## 排版 | 收集元素进行(hang)

为计算元素位置的准备工作

分行：

- 根据主轴尺寸，把元素分行
- 若设置了 no-wrap，则强心分配进第一行

> 将 flex item 一个一个放到第一行，直到有一个放不下了，则新建一行

---

## 排版 | 计算主轴

计算主轴方向：

- 找出所有带 flex 属性的元素
- 找出主轴方向的剩余尺寸，按比例分配给这些 flex 元素
- 若剩余空间为负数，将所有 flex 元素的宽度置为 0，等比例压缩剩余元素

---

## 排版 | 计算交叉轴

计算交叉轴：

- 根据每行中最大元素尺寸计算行高
- 根据行高 flex-align 和 item-align，确定元素具体位置

---

## 渲染 | 绘制单个元素

- 绘制需要以来一个图形环境
- 图形环境 - 绘制图片： images
- 绘制在一个 viewport 上进行
- 与绘制相关的属性
  - background-color
  - border
  - background-image
  - ...

---

## 渲染 | 绘制 DOM 树

- 递归调用 子元素的绘制方法 render 函数来完成整个 DOM 树的绘制
- 忽略一些不需要绘制的节点
- 实际浏览器中，**文字绘制是难点**，需要依赖字体库，这里忽略
- 实际浏览器中，还会对一些图层做compositing，这里忽略
